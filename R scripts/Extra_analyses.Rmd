---
title: "extra_scripts"
author: "John Swenson"
date: "8/2/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Extra analyses
```{r Extra analyses}
#-------------Extra analysis 1: Look for changes in gene expression upstream of 5' end (opposite of readthrough)------------------
#Assumes the count data from chunk 1 have been read into R and lowly expressed genes filtered out
#----------------Read in Data and set parameters  -----------------
#Read in gene boundaries bed file for expressed genes (default) or all genes
genes2 <- read.table("gene_boundaries.bed") 

head(genes2)
colnames(genes2) <- c("chromosome", "start", "end","gene_name", "V5","strand", "database", "feature", "V9", "notes") #Rename columns
genes2$gene_name <- as.character(genes$gene_name) #Convert columns to character

#Set distance for readthrough/normalization. Default  = 100bp
s2 <- 100

#Subset all genes for expressed genes
expressed_genes2 <- rownames_to_column(as.data.frame(y$counts), var="gene_name")  %>% #subset for genes that pass edgeR's filters
  as_tibble() %>% #convert to tibble  
  inner_join(genes2, by = "gene_name") %>% #join gene boundaries bed file and table of expressed genes, keeping only expressed genes
  select(chromosome, start, end, gene_name, V5, strand, database, feature, V9, notes) %>% #select relevant columns
  filter(chromosome != "ChrC" & chromosome != "ChrM") #Remove chloroplast and mitochondrial sequences

head(expressed_genes2)

nrow(genes2) #How many genes are present in the full bed file that inlcudes all genes?
nrow(expressed_genes2) #How many genes are included in the bed file that's been filtered for expressed genes?
genes2$gene_name[!genes2$gene_name %in% expressed_genes2$gene_name] #Which genes are in the annotation file and NOT expressed?

#Write file including full gene boundaries to use for intersecting with bedtools
#(expressed_genes, file = "references/expressed_gene_boundaries_stranded.bed", sep="\t", col.names = FALSE, row.names = FALSE, quote = FALSE)

# ------- Create boundaries for readthrough detection ------

#Make bed file for genic region.
##Normalize by taking the 100bp region upstream of the transcription start site for each gene. If the strand is negative, then set the start to the end (b/c it goes the other way) and set end to 100bp upstream
expressed_genes_downstream_genic_3prime <- expressed_genes2 %>% 
  mutate(start2 = ifelse(strand == "-", end, start)) %>% 
  mutate(end2 = ifelse(strand == "-", end - (s-1), start + (s-1))) %>% 
  select(chromosome, start2, end2, gene_name, V5, strand, database, feature, V9, notes)
head(expressed_genes_downstream_genic_3prime)

write.table(expressed_genes_downstream_genic_3prime, file = "expressed_genes_downstream_genic_3prime.bed", sep="\t", col.names = FALSE, row.names = FALSE, quote = FALSE)

#Make bed file for upstream region
#Use window of 100bp, and similarly switch start and stop for genes on the negative strand (b/c they go the other way)
expressed_genes_upstream_3prime <- expressed_genes2 %>% 
  mutate(start2 = ifelse(strand == "-", end, start - (s-1))) %>% 
  mutate(end2 = ifelse(strand == "-", end + (s-1), start)) %>% 
  select(chromosome, start2, end2, gene_name, V5, strand, database, feature, V9, notes)
head(expressed_genes_upstream_3prime)  
  
write.table(expressed_genes_upstream_3prime, file = "expressed_genes_upstream_3prime.bed", sep="\t", col.names = FALSE, row.names = FALSE, quote = FALSE)


#-------------Extra analysis 2: Differential expression combining heated treatments------------------------
counts <- data.frame(data.matrix(read.table(file="all_counts_stranded.matrix"))) #Import count data to R

head(counts) #Make sure that samples are ordered the same as the vector in the line below (i.e. make sure the samples will be names appropriately)

#rename column names to sample names
colnames(counts) <- c("h1-4-H1_S10", "h1-4-H2_S12", "h1-4-H3_S3", "h1-4-RT1_S1", "h1-4-RT2_S6", "h1-4-RT3_S8","sh2-H1_S11", "sh2-H2_S2", "sh2-H3_S4", "sh2-RT1_S5", "sh2-RT2_S7", "sh2-RT3_S9")

#Combine heated and unheated treatments into two groups
group_temp <- factor(c(rep(c("Heated", "Unheated"), each = 3, times = 2)))

y_temp <- DGEList(counts = counts, group = group_temp) #Create DGEList object with groups; #confirmed groups and samples are labeled correctly

keep_temp <- filterByExpr(y_temp) #Filter out lowly expressed genes that will mess with comparisons
y_temp <- y_temp[keep_temp,,keep.lib.sizes=FALSE]

#Set parameters and fit model
y_temp <- calcNormFactors(y_temp) #Normalize library sizes to account for some samples having genes that absorb a disproportionate amount of read depth
design_temp <- model.matrix(~0+group_temp) #Create design matrix (0+ replaces the intercept with a group)
y_temp <- estimateDisp(y_temp, design_temp, robust=TRUE) #Estimate dispersion for negative binomial model

fit_temp <- glmQLFit(y_temp, design_temp, robust=TRUE) #Fit the negative binomial model

#Make design matrix for all pairwise comparisons
comparisons_temp <- makeContrasts(Heated_vs_unheated = group_tempHeated - group_tempUnheated, levels=design_temp)

#Combine all comparisons into a single F statistic and p-value and extract top tags
comps_temp <- glmQLFTest(fit_temp, contrast=comparisons_temp)
tt_temp <- as.data.frame(topTags(comps_temp, n=15905)) #set n to total number of genes
nrow(tt_temp[tt_temp$FDR < 0.05,])


#Make MDS plot to ensure samples group together
points_temp <- c(rep(c(19,18), each=3, times=2))
colors_temp <- c(rep(c("blue", "red"), each = 3, times=2))
plotMDS(y_temp, col=colors_temp, pch=points_temp)
legend("top", legend=levels(group_temp), pch=points_temp[c(1,4)], col=colors_temp[c(1,4)], ncol=1)


###Isolate genes of interest for filtering
#Create filtered dataset for genes that are DE in heated treatments
#Must have run 'Group by temperature section' above
heated_v_unheated <- tt_temp %>%
  rownames_to_column(var = "gene") %>% 
  filter(FDR < 0.01) %>% 
  filter(logFC > 0) %>% 
  as_tibble()

#How many genes show readthrough  heated treatments?
#mean_ratios %>% inner_join(heated_v_unheated, by = "gene") %>% 
  #Set ratio filters
#  filter(sh2_H_mean > var1 & h1_4_H_mean > var1 & h1_4_RT_mean < var2 & sh2_RT_mean < var2) %>% 
#  inner_join(f_boundaries, by = "gene") %>% 
#  select(gene, chr, start, stop, strand, h1_4_H_mean, sh2_H_mean, h1_4_RT_mean, sh2_RT_mean, logFC) %>% 
#  mutate_at(6:10, ~ round(., 2)) %>% 
#  arrange(desc(logFC)) %>% 
#  summarize(n())
```
### **<p id="dge_end">DGE SCRIPT END</p>**

### Calculate readthrough length
First, merge reads from each sample using `bedtools merge`. 
Then, we create a new file for each sample where the end point of the read is 50bp downstream of the start point.

```{r}
##############################################################################
####-------Create file with shortened contig lengths for annotation------#####
##############################################################################

#Note that we're working with lists here, so any function that we want to run on one dataframe (sample), we can run on each one by including in a for loop that loops over each element of the list.

#Read in merged read files and make into list
files1 <- list.files(path = "~/R/R_working_dir/Collaborations/Minsoo/merged_bed_04.27.2021/", pattern = "*merged.bed", full.names = F)

f_merged <- sapply(files1, read_tsv, simplify=FALSE, col_names = FALSE)

#Save sample names in same order they appear in the above list for naming output files
samples <- as_tibble(names(f_merged)) %>% #Save names of files
  separate(col = "value", into = c("sample", "col1", "col2"), sep = "[.]") %>% 
  select(sample)

sample_names <- samples$sample

#Change end point of each read to 50bp downstream so we can hopefully annotate the correct gene
for(i in 1:length(f_merged)){
  #Rename columns
  colnames(f_merged[[i]])[1] <- "chromosome" 
  colnames(f_merged[[i]])[2] <- "read_start"
  colnames(f_merged[[i]])[3] <- "read_end"
  colnames(f_merged[[i]])[4] <- "strand"
  #if the strand is positive, then we need to switch the start and end. We switch the positive strand because the anti-sense strand was sequenced.
  f_merged[[i]] <- f_merged[[i]] %>% mutate(read_start = ifelse(strand == "+", read_end, read_start)) %>%
    #Change the end point of the contig to 50bp downstream
    mutate(trunc_end = ifelse(strand == "+", read_start - 50, read_start + 50),
               open1 = ".",
               open2 = ".")
  #Select relevant columns only
  f_merged[[i]] <- f_merged[[i]] %>% select(chromosome, read_start, trunc_end, open1, open2, strand)
}

#Write output file - one for each sample
for(j in 1:length(f_merged)){
  write_tsv(x = f_merged[[j]], file = paste0(sample_names[j], "_for_annot.bed"), col_names = FALSE)
}
```

**Transfer above output files to cluster and run below code to annotate**
```{bash}
#!/bin/bash
#intersect and count reads

#BSUB -q short
#BSUB -W 4:00
#BSUB -R rusage[mem=16000]
#BSUB -n 8
#BSUB -R span[hosts=1]
#BSUB -e intersect_annotate.err
#BSUB -oo intersect_annotate.log

#Load required modules
module load bedtools/2.29.2

for file in ./JDS_annotate/*.bed
do

sample=${file%%_for_annot.bed} #Store path and basename of file minus read info
out_name=${sample##*/} #Remove path, but keep basename top be used as a prefix to output

#Intersect with upstream gene region - stranded
bedtools intersect -a gene_boundaries.bed -b $file -S | awk '{print $1,$2,$3,$4,$5,$6}' > ./${out_name}_annotated.bed

done
```

**Transfer output files from above to local computer to reformat files in R**


```{r}
#################################################################
########---------Calculate readthrough length-----------#########
#################################################################

#Run below AFTER annotating with bedtools intersect
####------Read in and format merged bed files------####
files1 <- list.files(path = "~/R/R_working_dir/Collaborations/Minsoo/merged_bed_04.27.2021/", pattern = "*merged.bed", full.names = F)

f_merged <- NULL #In case the file from the part above is still in the environment

f_merged <- sapply(files1, read_tsv, simplify=FALSE, col_names = FALSE)

#Save sample names in same order they appear in the above list for naming output files
samples <- as_tibble(names(f_merged)) %>% #Save names of files
  separate(col = "value", into = c("sample", "col1", "col2"), sep = "[.]") %>% 
  select(sample)

sample_names <- samples$sample

#Format merged files for join
for(i in 1:length(f_merged)){
#Name columns for calculations and joins
  colnames(f_merged[[i]])[1] <- "chromosome"
  colnames(f_merged[[i]])[2] <- "read_start_tmp"
  colnames(f_merged[[i]])[3] <- "read_end_tmp"
  colnames(f_merged[[i]])[4] <- "strand"

  #If the strand is positive (again, anti-sense sequencing), we want to switch the start and end points
  f_merged[[i]] <- f_merged[[i]] %>% mutate(read_start = ifelse(strand == "+", read_end_tmp, read_start_tmp), 
                                            read_end = ifelse(strand == "+", read_start_tmp, read_end_tmp)) %>% 

  #Select the relevant columns only
  f_merged[[i]] <- f_merged[[i]] %>% select(chromosome, read_start, read_end, strand)
}

head(f_merged[[7]])

####-----Read in and format annotated bed files and gene_boundaries -------####
files2 <- list.files(path = "~/R/R_working_dir/Collaborations/Minsoo/merged_bed_04.27.2021/", pattern = "*annotated.bed", full.names = F)

f_annotated <- sapply(files2, read_delim, simplify=FALSE, col_names = FALSE, delim = " ")

#Gene boundaries; import and prepare for joining below
genes <- read.table("~/R/R_working_dir/Collaborations/Minsoo/merged_bed_04.27.2021/gene_boundaries_subset.bed") %>% 
  rename(chromosome = V1, gene_start_tmp = V2, gene_end_tmp = V3, gene = V4, open1 = V5, strand = V6) %>%
  #If the strand is NEGATIVE in the gene boundaries file, then we want to switch the start and end points. This is the opposite of the merged file where the positive strand was switched (bc the anti-sense was sequenced).
  mutate(gene_start = ifelse(strand == "-", gene_end_tmp, gene_start_tmp),
         gene_end = ifelse(strand == "-", gene_start_tmp, gene_end_tmp))


#Extract sample names in same order they' were 're in for naming output files below
samples2 <- as_tibble(names(f_annotated)) %>% #Save names of files
  separate(col = "value", into = c("sample", "col1"), sep = "[_]") %>% 
  select(sample)

sample_names2 <- samples2$sample

#Format annotated file for join
for(i in 1:length(f_annotated)){
  colnames(f_annotated[[i]])[1] <- "chromosome"
  colnames(f_annotated[[i]])[2] <- "read_start"
  colnames(f_annotated[[i]])[3] <- "trunc_end"
  colnames(f_annotated[[i]])[4] <- "gene"
  colnames(f_annotated[[i]])[5] <- "open1"
  colnames(f_annotated[[i]])[6] <- "strand"
  f_annotated[[i]]$start <- as.character(f_annotated[[i]]$read_start)
  f_annotated[[i]] <- f_annotated[[i]] %>% select(chromosome, read_start, gene, strand)
}


#Make empty list for loop below
f_annotated_all <- list()

#Join merged file with annotation file, then join again with gene boundaries file and rename columns
for(i in 1:length(f_merged)){
  f_annotated_all[[i]] <- f_merged[[i]] %>% left_join(f_annotated[[i]], by = c("chromosome", "read_start"))
  f_annotated_all[[i]] <- f_annotated_all[[i]] %>% left_join(genes, by = c("chromosome", "gene")) %>% 
    #Note that in the select function below, we are selecting the strand from the gene_boundaries file.
    select(chromosome, read_start, read_end, gene_start, gene_end, gene, strand)
}


#Make one more blank list for calculating readthrough length
f_annotated_all2 <- list()

##Calculate readthrough length and remove mitochondrial reads
for(i in 1:length(f_annotated_all)){
#Whether we want to subtract the gene end from the contig end or the contig end from the gene end depends on which strand was sequenced. For genes on the negative strand, the end position of a contig with readthrough will be numerically smaller than the end position of the gene. For genes on the positive strand, the end position of a contig with readthrough will be numerically larger than the end position of the gene.
    f_annotated_all2[[i]] <- f_annotated_all[[i]] %>% mutate(readthrough_length = ifelse(strand == "-", gene_end - read_end, read_end - gene_end)) %>%
    filter(readthrough_length > 0 & chromosome != "ChrM") %>% 
    arrange(desc(readthrough_length)) %>% 
    select(chromosome, read_start, read_end, gene_start, gene_end, gene, readthrough_length)
}

#Quick check for known readthrough genes in sh2-H3 sample -- both should appear in this file
f_annotated_all2[[9]] %>% filter(gene == "AT3G08970")
f_annotated_all2[[7]] %>% filter(gene == "AT1G74310")

#Write output files
for(j in 1:length(f_annotated_all2)){
  write_tsv(x = f_annotated_all2[[j]], file = paste0(sample_names2[j], "_annotated_readthrough_length.bed"), col_names = TRUE)
}
```